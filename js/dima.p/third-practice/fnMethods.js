// Array.prototype.forEach(()=>{})
// Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.
// Возвращает undefined

// Array.prototype.every()
// Array.prototype.some()
// Эти методы используются для проверки массива.
// Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
// Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.
// const arr = [1, -1, 2, -2, 3];
// console.log( arr.every(number => number>0) ); // false, не все положительные
// console.log( arr.some(number => number>0) ); // true, есть хоть одно положительное

// Array.prototype.map()
// Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
// Принимает колбэк функцию, которая может принимать 2 параметра, текущий элемент и его индекс

// Array.prototype.filter()
// Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
// Принимает колбэк функцию, которая может принимать 3 параметра, текущий элемент и его индекс

// Array.prototype.sort()
// console.log([12, 32, 2, 45, 67].sort((a, b) => a-b))
// Может или ничего не принимать или принимает колбэк с двумя параметрами
// Если метод вызывается без аргментов, то элементы сортируются путём преобразования их в строки 
// и сравнения строк в порядке следования кодовых точек Unicode. Например, слово "Вишня" 
// идёт перед словом "бананы". При числовой сортировке, 9 идёт перед 80, но поскольку числа 
// преобразуются в строки, то "80" идёт перед "9" в соответствии с порядком в Unicode.

// const fruit = ['арбузы', 'бананы', 'Вишня'];
// console.log(fruit.sort()); // ['Вишня', 'арбузы', 'бананы']

// const scores = [1, 2, 10, 21];
// console.log(scores.sort()); // [1, 10, 2, 21]

// const things = ['слово', 'Слово', '1 Слово', '2 Слова'];
// console.log(things.sort()); // ['1 Слово', '2 Слова', 'Слово', 'слово']

// Array.prototype.reduce()
// Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого 
// элемента массива с сохранением промежуточного результата. Это один из самых сложных методов для работы с массивами.

// const listRef = document.querySelector('.list')
// const markup = users.reduce((accum, user, ind) => accum + `<li id=${ind}>${user.name}</li>` , '')
// listRef.insertAdjacentHTML('beforeend', markup) // Like

// users.forEach(user => {
//     const li = `<li>${user.name}</li>`
//     listRef.insertAdjacentHTML('beforeend', li)
// }) // Dislike
// Аргументы функции callback(previousValue, currentItem, index, arr):

// previousValue – последний результат вызова функции, он же «промежуточный результат».
// currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
// index – номер текущего элемента.
// arr – обрабатываемый массив. В 99,9% не пишется, потому что метод сразу применяют на каком-то массиве

// Array.prototype.flatMap()
// Метод flatMap() сначала применяет функцию к каждому элементу, а затем преобразует полученый 
// результат в плоскую структуру и помещает в новый массив.
// const arr = [[23], [23], [777]]
// console.log(arr.flatMap(el => el))

// Array.prototype.find((el) => {})